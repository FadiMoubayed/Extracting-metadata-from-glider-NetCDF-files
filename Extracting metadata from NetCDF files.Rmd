---
title: "Extracting metadata from the netCDF files"
author: "Fadi Moubayed"
date: "9/14/2020"
output: html_document
---

### Loading packages
```{r message=FALSE,warning=FALSE}
# JSON libraries
library(rjson)
library(RJSONIO)
library(jsonlite)

# To read the netCDF file (check for better options!)
library(ncdf4)

# To get the min bounding box
library(sp)
library(shotGroups)

# To plot the track of the glider
library(spacetime)
library(trajectories)
library(leaflet)

# To format dates
library(lubridate)

# ?? Not sure why I was using this
library(tidyverse)

# to format text in the console (does not format text in R markdown)
require(crayon)

```


### Writing a function to get the Time dimenson from the glider netCDF file
The following function gets the time dimension from the glider netCDF file and converts it from double to Unix time. The function also extracts the time stamp and the date as well.
This function returns a dataframe that has the formatted time in addition the timestamp and the date.
This function takes a ncdf4 object as an argument.
```{r}
formatTimeDim <- function(file){
    tryCatch(
        expr = {
            # Getting the time dimension
            time = file$dim$TIME
            # Formatting time
            time_formatted = as.POSIXct(time$vals, origin="1970-01-01")
            # Extracting the time stamp from the unix time object
            timeStamp = format(time_formatted,'%H:%M:%S')
            # Extracting the date from the unix time object
            date = as.Date(time_formatted)
            # Combining the formatted time, the time stamp and the date in one data frame
            all = cbind.data.frame(time_formatted, timeStamp, date)
            
            message('The time dimension has been successfully formatted!')
          # returning the dataframe
          return(all)
            
        },
        error = function(e){
            message('Caught an error!')
            print(e)
        },
        warning = function(w){
            message('Caught an warning!')
            print(w)
        }
    )    
}
```

### Combining lat and long with time

This function should return a dataframe that has the lat, lon, the time formatted, time stamp and date with no NA data.
```{r}
combineLatLongWithTime <- function(filePath){
    tryCatch(
        expr = {
              # Reading the file
              file = nc_open(filePath)
              
              # Getting the latitude and longitude
              lon = ncvar_get(file,"LONGITUDE")
              lat = ncvar_get(file,"LATITUDE")
              
              # Calling the time function to get the dataframe that has the time formatted
              time = formatTimeDim(file)
              
              # Combining the time data frame with lat and long. This dataframe has NA values
              dataframe = cbind.data.frame(lat, lon, time)
              
              
              cat(bold("The number of NA this file has is: ", sum(is.na(dataframe))))
              cat("\n")
              
              # removing NA values
              dataframe_No_NA = dataframe %>% drop_na()
              
              return(dataframe_No_NA)
            
            message("dataframe successfully created!")
        },
        error = function(e){
            message('Caught an error!')
            print(e)
        },
        warning = function(w){
            message('Caught an warning!')
            print(w)
        }
    )    
}

```

### A function to plot the track of the netCDF file
This function takes the a datafram that has lat, lon, time_formatted, time stamp and date as an argument. This is the output of the function combineLatLongWithTime
I am not sure how to select the first tow colomns of the dataframe that has lat, lon, time......
is it better if I put lat,lon in a seperate dataframe????
It looks to me that lat_lon_time_No_NA %>% select(1:2) makes things more complicated!!!
```{r}
plotMissionTrack = function(lat_lon_time_No_NA){
  # Setting the reference system
  crs = CRS("+proj=longlat +datum=WGS84")
  # Creating a spatial points object
  sp = SpatialPoints(lat_lon_time_No_NA %>% select(1:2),crs)
  # Getting time
  time = lat_lon_time_No_NA$time_formatted
  # Getting data
  data = data.frame(lat_lon_time_No_NA %>% select(1:2))
  # Creating an STIDF object
  stidf = STIDF(sp, time, data)
  # Creating a track object
  glider_track = Track(stidf)
  # plotting the map
   return(leaflet() %>%addTiles() %>% addPolylines(lat = glider_track@data[,1], lng = glider_track@data[,2]))
}
```

### A function to get the first value of each day in the dataframe
This function also takes a dataframe that has lat, lon, time_fomratted, timestamp and date as an input. This is the output of the function combineLatLongWithTime.
```{r}
getMissionTrackLabels = function(lat_lon_time_No_NA){
  # Splitting the dataframe based on date
  # This results in a list of dataframes
  list = split(lat_lon_time_No_NA, lat_lon_time_No_NA$date)
  #This provides the first row of each day in the data frame
  first_days = do.call(rbind, (lapply(list, function(x) x[1,])))
  return(first_days)
}

```

### A function to plot the mission track with labels
I'm still thinking of plotting the first value of the mission in green and the last value in red. I think this requiers extracting the first value in a separate list or a dataframe and the same for the last value and then add them to the plotting function.
```{r}
plotMissionTrackWithLabels = function(lat_lon_time_No_NA){
  track = plotMissionTrack(lat_lon_time_No_NA)
  first_days = getMissionTrackLabels(lat_lon_time_No_NA)
  return (track %>% addAwesomeMarkers(data = first_days, lat = ~first_days$lat, lng = ~first_days$lon, label = first_days$time_formatted))
}
```

### A function that returns a list of plots. This includs the mission track and the mission track with labels 
```{r}
plotMissionTracks = function(filePath){
  lat_lon_time_No_NA = combineLatLongWithTime(filePath)

  MissionTrack = plotMissionTrack(lat_lon_time_No_NA)
  
  x3 = getMissionTrackLabels(lat_lon_time_No_NA)
  
  MissionTrackWithLabels = plotMissionTrackWithLabels(lat_lon_time_No_NA)
  
  return(list(MissionTrack, MissionTrackWithLabels))

}
```

### Providing the path to the netCDF file
```{r}
# This is where the netCDF data files reside
netCDF_Data_Files_Path = "/home/fadi/DataX1/University/WWU/WWU 5/netCDF sample files/"

#File1
# This is the files that needs to be read
netCDF_File1_Name = "wallis_mooset01_R.nc"
# This is the complete path to the netCDF file that is being read
file_Path_File1 = paste0(netCDF_Data_Files_Path,netCDF_File1_Name)

#File2
# This is the files that needs to be read
netCDF_File2_Name = "sg558_fram_jun2013_R.nc"
# This is the complete path to the netCDF file that is being read
file_Path_File2 = paste0(netCDF_Data_Files_Path,netCDF_File2_Name)

#File3
# This is the files that needs to be read
netCDF_File3_Name = "ideep02_0012_R.nc"
# This is the complete path to the netCDF file that is being read
file_Path_File3 = paste0(netCDF_Data_Files_Path,netCDF_File3_Name)
```

### Testing plotting the mission track for multiple files
```{r}
plotMissionTracks(file_Path_File1)
plotMissionTracks(file_Path_File2)
plotMissionTracks(file_Path_File3)
```





### Getting the min bounding box using the library sp
```{r}
lat_lon_time_No_NA_File1 = combineLatLongWithTime(file_Path_File1)
# Converting the dataframe to a SpatialPoints object
lat_lon_spatial_file1 = SpatialPoints(lat_lon_time_No_NA_File1 %>% select(1:2))
# Applying the bbox function
bb_sp = bbox(lat_lon_spatial_file1)

head(lat_lon_spatial_file1)
bb_sp
```
### Getting the bbox using the library shotGroups
This function also returns the width and height of the bounding box. Since the projection is WGS84. This information is not useful.
```{r}
lat_lon = lat_lon_time_No_NA_File1 %>% select(1:2)
names(lat_lon)[1] = "point.x"
names(lat_lon)[2] = "point.y"
bb = getBoundingBox(lat_lon)
bb
```


















### Generalizing the mission track
I am modifying the function plotMissionTrack to only get the track object instead of plotting it


This function takes the a datafram that has lat, lon, time_formatted, time stamp and date as an argument. This is the output of the function combineLatLongWithTime
I am not sure how to select the first tow colomns of the dataframe that has lat, lon, time......
is it better if I put lat,lon in a seperate dataframe????
It looks to me that lat_lon_time_No_NA %>% select(1:2) makes things more complicated!!!

```{r}
getMissionTrack = function(lat_lon_time_No_NA){
  # Setting the reference system
  crs = CRS("+proj=longlat +datum=WGS84")
  # Creating a spatial points object
  sp = SpatialPoints(lat_lon_time_No_NA %>% select(1:2),crs)
  # Getting time
  time = lat_lon_time_No_NA$time_formatted
  # Providing the mission's coordinates
  data = data.frame(lat_lon_time_No_NA %>% select(1:2))
  # Creating an STIDF object
  stidf = STIDF(sp, time, data)
  # Creating a track object
  glider_track = Track(stidf)
  # Returning a track object
  return(glider_track)
}

```
```{r}
lat_lon_time_No_NA_File1= combineLatLongWithTime(file_Path_File3)
mission_Track_File3 = getMissionTrack(lat_lon_time_No_NA_File1)
mission_Track_File3_generalized = generalize(mission_Track_File3, distance = 100)
```


```{r}
# plot(mission_Track_File3)
plot(mission_Track_File3_generalized, main = "The generalized track")
plot(mission_Track_File3, main = "The whole track")
```

This function plots the generalized mission track
The generalize function in trajectories is throwing me the following error:
          "CRS object has comment, which is lost in output"

```{r}
plotMissionTrackGeneralized = function(lat_lon_time_No_NA){
  # Setting the reference system
  crs = CRS("+proj=longlat +datum=WGS84")
  # Creating a spatial points object
  sp = SpatialPoints(lat_lon_time_No_NA %>% select(1:2),crs)
  # Getting time
  time = lat_lon_time_No_NA$time_formatted
  # Getting data
  data = data.frame(lat_lon_time_No_NA %>% select(1:2))
  # Creating an STIDF object
  stidf = STIDF(sp, time, data)
  # Creating a track object
  glider_track = Track(stidf)
  # Generalizing the track
  glider_track_generalized = generalize(glider_track, distance = 100)
  # plotting the map
   return(leaflet() %>%addTiles() %>% addPolylines(lat = glider_track_generalized@data[,1], lng = glider_track_generalized@data[,2]))
}

plotMissionTrackGeneralized(lat_lon_time_No_NA_File1)
```























```{r}

```


```{r}

```