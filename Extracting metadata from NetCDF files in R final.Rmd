---
title: "Extracting metadata from NetCDF files in R final"
output: html_document
---
### Loading packages
```{r message=FALSE,warning=FALSE}
# NetCDF libraries
library(ncdf4)

# to use the index function
library(zoo)

# spatial
library(sp)

library(dplyr)
library(tidyverse)

library(spacetime)
library(trajectories)

# writing geoJOSN
library(geojsonio)
library(geojson)
```

### Providing sample NetCFD files and the path to the output GeoJSON files
```{r}
# This is where the netCDF data files reside
files_Directory = "/home/fadi/DataX1/University/WWU/WWU 5/netCDF sample files/"
# This is the files that needs to be read
file_Name = "amerigo_coconet_R.nc"
# This is the complete path to the netCDF file that is being read
file_Path = paste0(files_Directory,file_Name)
# Reading the file
file = nc_open(file_Path)

# Providing the GeoJSON output directory
geoJSONOutput = "/home/fadi/DataX1/University/WWU/WWU 5/Task 2/GeoJson/geoJSON Output/"
```

## 1. Getting variabels names and dimensions

### Getting the variabels available in the file
```{r}
#Getting the names of variables in the netCDF file
variabels = names(file$var) # this is of type vector
#Getting the number of variables in the netCDF file
number_of_variables = length(variabels)
```

### Getting the dimensions available in the file
```{r}
#Getting the names of dimensions in the netCDF file
dimensions = names(file$dim) # this is of type vector
#Getting the number of dimensions in the netCDF file
number_of_dimensions = length(dimensions)
```

## 2. Formatiing time and getting coordinates

### Writing a function to get the Time dimenson from the glider netCDF file
The following function gets the time dimension from the glider netCDF file and converts it from double to Unix time. The function also extracts the time stamp and the date as well.
This function returns a dataframe that has the formatted time in addition the timestamp and the date.
This function takes a ncdf4 object as an argument.
```{r}
formatTimeDim <- function(file){
    tryCatch(
        expr = {
            # Getting the time dimension
            time = file$dim$TIME
            # Formatting time
            time_formatted = as.POSIXct(time$vals, origin="1970-01-01")
            # Extracting the time stamp from the unix time object
            timeStamp = format(time_formatted,'%H:%M:%S')
            # Extracting the date from the unix time object
            date = as.Date(time_formatted)
            # Combining the formatted time, the time stamp and the date in one data frame
            all = cbind.data.frame(time_formatted, timeStamp, date)
            
            message('The time dimension has been successfully formatted!')
          # returning the dataframe
          return(all)
            
        },
        error = function(e){
            message('Caught an error while formatting time!')
            print(e)
        },
        warning = function(w){
            message('Caught an warning while formatting time!')
            print(w)
        }
    )    
}
```

### Combining lat and long with time

This function should return a dataframe that has the lat, lon, the time formatted, time stamp and date with no NA data.
```{r}
combineLatLongWithTime <- function(filePath){
    tryCatch(
        expr = {
              # Reading the file
              file = nc_open(filePath)
              # Getting the latitude and longitude
              lon = ncvar_get(file,"LONGITUDE")
              lat = ncvar_get(file,"LATITUDE")
              # Calling the time function to get the dataframe that has the time formatted
              time = formatTimeDim(file)
              # Combining the time data frame with lat and long. This dataframe has NA values
              dataframe = cbind.data.frame(lat, lon, time)
              
              # cat(bold("The number of NA this file has is: ", sum(is.na(dataframe))))
              # cat("\n")
              
              # removing NA values
              dataframe_No_NA = dataframe %>% drop_na()
              
              return(dataframe_No_NA)
            
            message("Time successfully combined with Lat and Long!")
        },
        error = function(e){
            message('Caught an error while combining time with Lat and Long!')
            print(e)
        },
        warning = function(w){
            message('Caught an warning while combining time with Lat and Long!')
            print(w)
        }
    )    
}

```

## 3. Creating the mission track

### A function to get the track of the netCDF file
This function takes the a datafram that has lat, lon, time_formatted, time stamp and date as an argument. This is the output of the function combineLatLongWithTime
I am not sure how to select the first tow colomns of the dataframe that has lat, lon, time......
is it better if I put lat,lon in a seperate dataframe????
It looks to me that lat_lon_time_No_NA %>% select(1:2) makes things more complicated!!!

```{r}
getMissionTrack = function(lat_lon_time_No_NA){
  tryCatch(
        expr = {
              # Setting the reference system
              crs = CRS("+proj=longlat +datum=WGS84")
              # Creating a spatial points object
              sp = SpatialPoints(lat_lon_time_No_NA %>% select(1:2),crs)
              # Getting time
              time = lat_lon_time_No_NA$time_formatted
              # Providing the mission's coordinates
              data = data.frame(lat_lon_time_No_NA %>% select(1:2))
              # Creating an STIDF object
              stidf = STIDF(sp, time, data)
              # Creating a track object
              gliderTrack = Track(stidf)
              # Printing a confirmation message in console
              message("Mission track object successfully created!")
              # Returning a track object
              return(gliderTrack)
        },
        error = function(e){
            message('Caught an error while creating mission track object!')
            print(e)
        },
        warning = function(w){
            message('Caught an warning while while creating mission track object!')
            print(w)
        }
    )
}
```

### A function to get the first value of each day in the dataframe
This function also takes a dataframe that has lat, lon, time_fomratted, timestamp and date as an input. This is the output of the function combineLatLongWithTime.
```{r}

getMissionTrackLabels = function(lat_lon_time_No_NA){
    tryCatch(
        expr = {
              # Splitting the dataframe based on date
              # This results in a list of dataframes
              list = split(lat_lon_time_No_NA, lat_lon_time_No_NA$date)
              #This provides the first row of each day in the data frame
              first_days = do.call(rbind, (lapply(list, function(x) x[1,])))
              # Printing a confirmation message in console
              message("Mission track labels successfully created!")
              # Returning the labels list
              return(first_days)     
        },
        error = function(e){
            message('Caught an error while creating mission track labels!')
            print(e)
        },
        warning = function(w){
            message('Caught an warning while while creating mission track labels!')
            print(w)
        }
    )
}
```

### Generalizing the mission track
This function returns a dataframe with the generalized track's coordinates
This will be converted to a list of coordinates using the function I wrote
```{r}
generalizeMissionTrack = function(missionTrack){
  tryCatch(
        expr = {
            # Generalizing the mission track
            generalizedTrack = generalize(missionTrack, distance = 2000, tol = 0.006)
            # Getting the coordinates of the generalized track
            generalizedTrackCoordinates = coordinates(generalizedTrack)
            message('Mission track is successfully generalized!')
            return(generalizedTrackCoordinates)     
        },
        error = function(e){
            message('Caught an error while generalizing the mission track!')
            print(e)
        },
        warning = function(w){
            message('Caught an warning while while generalizing the mission track!')
            print(w)
        }
    )
}
```

## 4. Saving metadata to a GeoJSON file
### A function to convert coordinates from a martix or a dataframe to a numeric list
```{r}
coordsToNumericList = function(matrix){
  tryCatch(
        expr = {
            list = list()
            for(i in 1:length(matrix[,1])){
              list[[i]]= c(matrix[[i,1]], matrix[[i,2]])
            }
            message('The generalized track coordinates successfully converted a numeric list!')
            return(list)    
        },
        error = function(e){
            message('Caught an error while creating mission track labels!')
            print(e)
        },
        warning = function(w){
            message('Caught an warning while while creating mission track labels!')
            print(w)
        }
    )
}
```

### Creating the list of non spatial properties
I need to think how to do this in the best way
```{r}

```

### Creating the GoeJSON file
Geometry is the generalized track coordinates
properties is a named list that has all the non spatial properties

```{r}
writeMetadataToGeoJSON = function(geometry, properties,outputDirectory, fileName){
  
  tryCatch(
        expr = {
            # Converting the coordinates from a dataframe to a list
            geometryList = coordsToNumericList(geometry)
            # Creating a list that contains the necessary information to create a linestring
            # Json object which will be used to create the linestring
            lineStringInfo = list(type = "LineString",coordinates = geometryList)
            # Converting the linestring info to JSON
            lineStringInfoJSON = rjson::toJSON(lineStringInfo)
            # Creating a linestring object out of the lineStringInfoJSON
            trackLineString = linestring(lineStringInfoJSON)
            # Creating the gosJSON file
            trackAsFeature = trackLineString %>% feature()  %>%  properties_add( .list = properties)
            # Creating a name for the output file
            outputFile = paste0(outputDirectory ,fileName, "_metadata.goejson")
            # writing the goeJSON file to disk
            geo_write(trackAsFeature, file = outputFile)
            
            message('The metadata has been sucessfully saved as a GeoJSON on disk!')
        },
        error = function(e){
            message('Caught an error while creating mission track labels!')
            print(e)
        },
        warning = function(w){
            message('Caught an warning while while creating mission track labels!')
            print(w)
        }
    )
}
```

### Testing
Maybe this should be encapsulated into one function in the end 
```{r}
# Formatting time and getting lat and lon in one dataframe
lat_lon_time = combineLatLongWithTime(file_Path)
# Getting the mission track
missionTrack = getMissionTrack(lat_lon_time)
# Getting the mission track labels
missionTrackLabels = getMissionTrackLabels(lat_lon_time)

```

### Getting mission track informati
```{r}
# Getting the bounding box
bbox = missionTrack@sp@bbox
# Getting the length of the track in KM
length = sum(missionTrack@connections$distance) /1000
# Getting the number of points the track has
numberOfPoints = length(missionTrack@sp)
# Getting the time period
ix = index(missionTrack@time)
tmin = min(ix)
tmax = max(ix)
timePeriod = paste0("[",tmin," , " ,tmax,"]")
```

### Creating the non spatial properties
Extra non spatial properties can be added to this list
```{r}
# Getting the mission non spatial properties
properties = list("variabels names" = variabels, "number of variables"= number_of_variables,"dimensions names" = dimensions, "Bounding box" = bbox, "Track Length" = length, "Number of Points" = numberOfPoints, "Time Period" = timePeriod)

```

### Generalizing the track and creating the GeoJSON file
```{r}
# Generalizing the mission's track
generalizedTrack = generalizeMissionTrack(missionTrack)
# Writing the geoJSON file to disk
writeMetadataToGeoJSON(generalizedTrack, properties, geoJSONOutput, file_Name)
```



```{r}

```

```{r}

```


```{r}

```




